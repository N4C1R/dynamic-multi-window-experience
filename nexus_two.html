<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Nexus 2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #000005;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .info {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 0.75rem;
            border-radius: 0.5rem;
            color: #9ca3af;
            font-size: 0.875rem;
            border: 1px solid #374151;
        }
        .info strong { color: #e5e7eb; }
        #openWindowBtn {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: rgba(22, 163, 74, 0.4);
            border: 1px solid #16a34a;
            color: #e5e7eb;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 15px rgba(22, 163, 74, 0.3);
        }
        #openWindowBtn:hover {
            background: rgba(22, 163, 74, 0.7);
            box-shadow: 0 0 25px rgba(22, 163, 74, 0.5);
        }
    </style>
</head>
<body>
<div class="info">
    <strong>Core Nexus 2</strong><br>
    Status: Awaiting Link
</div>
<canvas id="canvas"></canvas>
<button id="openWindowBtn" style="display: none;">Launch Nexus 1</button>

<script>
    // --- ENHANCED CONFIGURATION ---
    const WINDOW_ID = 2;
    const ATTRACTION_RADIUS = 900;
    const MERGE_DISTANCE = 100;
    const PARTICLE_COUNT = 120;
    const PARTICLE_LIFESPAN = 180;
    const CORE_COLOR = '#16a34a'; // Green
    const PARTICLE_COLOR = 'rgba(74, 222, 128, 0.9)'; // Lighter Green
    const HOT_PARTICLE_COLOR = 'rgba(236, 72, 153, 0.9)'; // Magenta
    const MERGED_COLOR = '#a855f7'; // Purple
    const MERGED_PARTICLE_COLOR = 'rgba(192, 132, 252, 0.9)';

    // --- SETUP ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const infoStatus = document.querySelector('.info');
    const openBtn = document.getElementById('openWindowBtn');

    let openerWindowPos = null;
    let lastSeenTimestamp = 0;
    let particles = [];
    let transferredParticles = [];
    let ghostParticles = [];
    let stars = [];
    let nebulaColors = [];
    let activeWindowId = 1;
    let ringAngle1 = 0;
    let ringAngle2 = 0;
    let partnerFound = false;
    let popupBlocked = false;

    // --- ENHANCED PARTICLE CLASS WITH WAVY FILAMENTS ---
    class Particle {
        constructor({x, y, vx = 0, vy = 0, life = Math.random() * PARTICLE_LIFESPAN, color, targetX, targetY}) {
            this.x = x; this.y = y; this.vx = vx; this.vy = vy;
            this.life = life; this.baseLife = this.life > 0 ? this.life : PARTICLE_LIFESPAN;
            this.color = color;
            this.wavePhase = Math.random() * Math.PI * 2;
            this.waveAmplitude = Math.random() * 15 + 5; // Increased amplitude
            this.waveFreq = Math.random() * 0.1 + 0.1; // Increased frequency
            this.targetX = targetX;
            this.targetY = targetY;
            this.pathAngle = targetX && targetY ? Math.atan2(targetY - y, targetX - x) : 0;
        }

        update(attractorX, attractorY, attractionForce) {
            const dx = attractorX - this.x;
            const dy = attractorY - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 1) {
                this.vx += (dx / dist) * attractionForce;
                this.vy += (dy / dist) * attractionForce;
            }

            // Update path angle for wave direction
            if (this.targetX && this.targetY) {
                this.pathAngle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
            }

            this.x += this.vx;
            this.y += this.vy;
            this.vx *= 0.98;
            this.vy *= 0.98;
            this.life--;
        }

        draw(blendColor = null, blendAmount = 0) {
            let finalColor = this.color;
            if (blendColor && blendAmount > 0) {
                finalColor = lerpColor(this.color, blendColor, blendAmount);
            }

            const alpha = (this.life / this.baseLife) * 0.9;
            const flicker = Math.random() * 0.2 + 0.8;

            // Enhanced wave effect with directional waves
            const waveOffset = Math.sin(this.life * this.waveFreq + this.wavePhase) * this.waveAmplitude;
            const perpX = -Math.sin(this.pathAngle);
            const perpY = Math.cos(this.pathAngle);

            const drawX = this.x + perpX * waveOffset;
            const drawY = this.y + perpY * waveOffset;

            const tailLength = 8 + (this.waveAmplitude/2);
            const tailX = drawX - this.vx * tailLength;
            const tailY = drawY - this.vy * tailLength;

            const grad = ctx.createLinearGradient(drawX, drawY, tailX, tailY);
            grad.addColorStop(0, finalColor.replace(/[\d\.]+\)$/g, `${alpha * flicker})`));
            grad.addColorStop(1, finalColor.replace(/[\d\.]+\)$/g, `0)`));

            ctx.strokeStyle = grad;
            ctx.lineWidth = 2.5; // Slightly thicker lines
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(drawX, drawY);
            ctx.lineTo(tailX, tailY);
            ctx.stroke();
        }
    }

    // --- INITIALIZATION ---
    function init() {
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('focus', () => channel.postMessage({ type: 'focus', id: WINDOW_ID }));
        openBtn.addEventListener('click', () => {
            window.open('nexus_one.html', 'PortalWindow1', 'width=400,height=400,left=100,top=200');
            openBtn.style.display = 'none';
            popupBlocked = false;
        });
        resizeCanvas();

        channel.postMessage({ type: 'ping', id: WINDOW_ID });
        setTimeout(() => {
            if (!partnerFound) {
                const newWindow = window.open('nexus_one.html', 'PortalWindow1', 'width=400,height=400,left=100,top=200');
                if (!newWindow) popupBlocked = true;
            }
        }, 250);

        animate();
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        stars = [];
        nebulaColors = [
            { x: Math.random() * canvas.width, y: Math.random() * canvas.height, r: Math.random() * 400 + 200, color: 'rgba(34, 197, 94, 0.1)' },
            { x: Math.random() * canvas.width, y: Math.random() * canvas.height, r: Math.random() * 300 + 150, color: 'rgba(168, 85, 247, 0.05)' }
        ];
        if (canvas.width > 0 && canvas.height > 0) {
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    z: Math.random() * 2.5 + 0.5
                });
            }
        }
    }

    // --- COMMUNICATION ---
    const channel = new BroadcastChannel('portal_nexus_channel');
    channel.onmessage = (event) => {
        if (!event.data) return;
        switch(event.data.type) {
            case 'pos1':
                openerWindowPos = event.data.data;
                lastSeenTimestamp = Date.now();
                break;
            case 'particle_transfer':
                if (event.data.target === WINDOW_ID) {
                    transferredParticles.push(
                        new Particle({
                            ...event.data.particle,
                            targetX: window.innerWidth / 2,
                            targetY: window.innerHeight / 2
                        })
                    );
                }
                break;
            case 'ghost_particle':
                if (event.data.target === WINDOW_ID) {
                    ghostParticles.push(event.data.particle);
                }
                break;
            case 'focus':
                activeWindowId = event.data.id;
                break;
            case 'ping':
            case 'pong':
                if (event.data.id !== WINDOW_ID) {
                    partnerFound = true;
                    channel.postMessage({ type: 'pong', id: WINDOW_ID });
                }
                break;
        }
    };

    // --- MAIN ANIMATION LOOP ---
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();

        const myPos = getMyPosition();
        channel.postMessage({ type: 'pos2', data: myPos });

        ringAngle1 += 0.01;
        ringAngle2 -= 0.005;

        const openerWindowPresent = Date.now() - lastSeenTimestamp < 1500;

        if (!openerWindowPresent) {
            handleNoLink(myPos);
            requestAnimationFrame(animate);
            return;
        }

        openBtn.style.display = 'none';
        const { dist } = calculateDistance(myPos, openerWindowPos);

        if (dist < MERGE_DISTANCE) {
            const isTopWindow = activeWindowId === WINDOW_ID;
            infoStatus.innerHTML = `<strong>Core Nexus 2</strong><br>Status: MERGED (${isTopWindow ? 'Top' : 'Bottom'})`;
            drawMergedState(myPos, isTopWindow);
        } else if (dist < ATTRACTION_RADIUS) {
            infoStatus.innerHTML = `<strong>Core Nexus 2</strong><br>Status: Filaments Active`;
            updateAndDrawFilaments(myPos, openerWindowPos, dist);
            drawCore(myPos.cx, myPos.cy, CORE_COLOR, 40);
        } else {
            infoStatus.innerHTML = `<strong>Core Nexus 2</strong><br>Status: Stable`;
            drawCore(myPos.cx, myPos.cy, CORE_COLOR, 40);
        }

        ghostParticles.forEach(p => new Particle(p).draw());
        ghostParticles = [];

        requestAnimationFrame(animate);
    }

    // --- DRAWING & LOGIC FUNCTIONS ---
    function drawMergedState(myPos, isTop) {
        const coreRadius = isTop ? 60 : 55;
        drawCore(myPos.cx, myPos.cy, MERGED_COLOR, coreRadius, isTop ? 1.0 : 0.7);
        if (particles.length < PARTICLE_COUNT) {
            particles.push(new Particle({
                x: myPos.cx,
                y: myPos.cy,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                color: MERGED_PARTICLE_COLOR
            }));
        }
        updateParticleList(particles, myPos, openerWindowPos, myPos.cx, myPos.cy, -0.02, 1);
    }

    function updateAndDrawFilaments(myPos, otherPos, dist) {
        const baseRadius = 40;
        const pulse = Math.sin(Date.now() * 0.002) * 5;
        const currentCoreRadius = baseRadius + pulse;

        const dx = (otherPos.x + otherPos.cx) - (myPos.x + myPos.cx);
        const dy = (otherPos.y + otherPos.cy) - (myPos.y + myPos.cy);
        const angle = Math.atan2(dy, dx);

        if (particles.length < PARTICLE_COUNT && Math.random() > 0.3) {
            const spawnX = myPos.cx + Math.cos(angle) * currentCoreRadius;
            const spawnY = myPos.cy + Math.sin(angle) * currentCoreRadius;
            const initialSpeed = 2.5;
            const initialVx = Math.cos(angle) * initialSpeed;
            const initialVy = Math.sin(angle) * initialSpeed;

            particles.push(new Particle({
                x: spawnX,
                y: spawnY,
                vx: initialVx,
                vy: initialVy,
                color: PARTICLE_COLOR,
                targetX: otherPos.cx + (otherPos.x - myPos.x),
                targetY: otherPos.cy + (otherPos.y - myPos.y)
            }));
        }

        const attractorX = otherPos.x - myPos.x + otherPos.cx;
        const attractorY = otherPos.y - myPos.y + otherPos.cy;
        const attractionForce = 1 - (dist / ATTRACTION_RADIUS);
        const blendAmount = Math.max(0, 1 - (dist - MERGE_DISTANCE) / (ATTRACTION_RADIUS / 2 - MERGE_DISTANCE));

        updateParticleList(particles, myPos, otherPos, attractorX, attractorY, attractionForce, 1, HOT_PARTICLE_COLOR, blendAmount);
        updateParticleList(transferredParticles, myPos, otherPos, attractorX, attractorY, attractionForce, 1, HOT_PARTICLE_COLOR, blendAmount);
    }

    function updateParticleList(list, myPos, otherPos, attractorX, attractorY, attractionForce, targetId, blendColor, blendAmount) {
        for (let i = list.length - 1; i >= 0; i--) {
            const p = list[i];
            p.update(attractorX, attractorY, attractionForce * 0.5);
            const screenX = myPos.x + p.x;
            const screenY = myPos.y + p.y;

            // Enhanced boundary detection with particle transfer
            const inOtherWindow = otherPos &&
                screenX >= otherPos.x &&
                screenX <= otherPos.x + otherPos.width &&
                screenY >= otherPos.y &&
                screenY <= otherPos.y + otherPos.height;

            if (inOtherWindow) {
                channel.postMessage({
                    type: 'particle_transfer',
                    target: targetId,
                    particle: {
                        x: screenX - otherPos.x,
                        y: screenY - otherPos.y,
                        vx: p.vx,
                        vy: p.vy,
                        life: p.life,
                        color: p.color
                    }
                });
                list.splice(i, 1);
                continue;
            }

            // Enhanced ghost particles at boundaries
            const ghostThreshold = 30;
            const nearBoundary =
                p.x > myPos.width - ghostThreshold ||
                p.x < ghostThreshold ||
                p.y > myPos.height - ghostThreshold ||
                p.y < ghostThreshold;

            if (otherPos && nearBoundary) {
                channel.postMessage({
                    type: 'ghost_particle',
                    target: targetId,
                    particle: {
                        x: screenX - otherPos.x,
                        y: screenY - otherPos.y,
                        vx: p.vx,
                        vy: p.vy,
                        life: p.life,
                        color: p.color
                    }
                });
            }

            p.draw(blendColor, blendAmount);
            if (p.life <= 0) list.splice(i, 1);
        }
    }

    function drawBackground() {
        if (canvas.width === 0 || canvas.height === 0) return;

        // Draw nebula
        nebulaColors.forEach(neb => {
            const grad = ctx.createRadialGradient(neb.x, neb.y, 0, neb.x, neb.y, neb.r);
            grad.addColorStop(0, neb.color);
            grad.addColorStop(1, 'rgba(0,0,5,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        });

        // Draw stars with parallax effect
        ctx.fillStyle = '#FFF';
        stars.forEach(star => {
            const parallaxX = window.screenX / (star.z * 10);
            const parallaxY = window.screenY / (star.z * 10);
            let x = (star.x - parallaxX) % canvas.width;
            let y = (star.y - parallaxY) % canvas.height;

            if (x < 0) x += canvas.width;
            if (y < 0) y += canvas.height;

            const size = (3 - star.z) * 0.5;
            ctx.globalAlpha = 1 / star.z * 0.5;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;
    }

    function drawCore(x, y, color, baseRadius, opacity = 1.0) {
        ctx.globalAlpha = opacity;
        const pulse = Math.sin(Date.now() * 0.002) * 5;
        const radius = baseRadius + pulse;

        // Core rings
        ctx.strokeStyle = color + '80';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(x, y, radius * 1.5, radius * 0.5, ringAngle1, 0, Math.PI * 2);
        ctx.stroke();

        ctx.strokeStyle = color + '40';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(x, y, radius * 0.8, radius * 1.8, ringAngle2, 0, Math.PI * 2);
        ctx.stroke();

        // Core glow
        for (let i = 4; i > 0; i--) {
            const bloomRadius = radius + i * 10;
            const grad = ctx.createRadialGradient(x, y, radius, x, y, bloomRadius);
            grad.addColorStop(0, color + '20');
            grad.addColorStop(1, color + '00');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, bloomRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Core body
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    function handleNoLink(myPos) {
        if (popupBlocked) {
            infoStatus.innerHTML = `<strong>Core Nexus 2</strong><br>Status: Pop-up Blocked`;
            openBtn.style.display = 'block';
        } else {
            infoStatus.innerHTML = `<strong>Core Nexus 2</strong><br>Status: Awaiting Link`;
        }
        drawCore(myPos.cx, myPos.cy, CORE_COLOR, 40);
    }

    // --- HELPERS ---
    function getMyPosition() {
        return {
            x: window.screenX,
            y: window.screenY,
            width: window.outerWidth,
            height: window.outerHeight,
            cx: window.innerWidth / 2,
            cy: window.innerHeight / 2
        };
    }

    function calculateDistance(pos1, pos2) {
        const dx = (pos1.x + pos1.width / 2) - (pos2.x + pos2.width / 2);
        const dy = (pos1.y + pos1.height / 2) - (pos2.y + pos2.height / 2);
        return { dist: Math.sqrt(dx * dx + dy * dy) };
    }

    function lerpColor(color1, color2, amount) {
        const c1 = color1.match(/\d+/g).map(Number);
        const c2 = color2.match(/\d+/g).map(Number);
        const r = Math.round(c1[0] + (c2[0] - c1[0]) * amount);
        const g = Math.round(c1[1] + (c2[1] - c1[1]) * amount);
        const b = Math.round(c1[2] + (c2[2] - c1[2]) * amount);
        return `rgba(${r}, ${g}, ${b}, 0.9)`;
    }

    init();
</script>
</body>
</html>