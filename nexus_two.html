<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Nexus 2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #000005;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .info {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 0.75rem;
            border-radius: 0.5rem;
            color: #9ca3af;
            font-size: 0.875rem;
            border: 1px solid #374151;
        }
        .info strong { color: #e5e7eb; }
    </style>
</head>
<body>
<div class="info">
    <strong>Core Nexus 2</strong><br>
    Status: Awaiting Link
</div>
<canvas id="canvas"></canvas>

<script>
    // --- ADVANCED CONFIGURATION ---
    const WINDOW_ID = 2;
    const ATTRACTION_RADIUS = 900;
    const MERGE_DISTANCE = 100;
    const PARTICLE_COUNT = 80;
    const PARTICLE_LIFESPAN = 120;
    const CORE_COLOR = '#16a34a'; // Green
    const PARTICLE_COLOR = 'rgba(74, 222, 128, 0.9)'; // Lighter Green
    const HOT_PARTICLE_COLOR = 'rgba(236, 72, 153, 0.9)'; // Magenta
    const MERGED_COLOR = '#a855f7'; // Purple
    const MERGED_PARTICLE_COLOR = 'rgba(192, 132, 252, 0.9)';

    // --- SETUP ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const infoStatus = document.querySelector('.info');

    let openerWindowPos = null;
    let lastSeenTimestamp = 0;
    let particles = [];
    let transferredParticles = [];
    let stars = [];
    let nebulaColors = [];
    let activeWindowId = 1;
    let ringAngle1 = 0;
    let ringAngle2 = 0;

    // --- PARTICLE CLASS ---
    class Particle {
        constructor({x, y, vx = (Math.random() - 0.5) * 2, vy = (Math.random() - 0.5) * 2, life = Math.random() * PARTICLE_LIFESPAN, color}) {
            this.x = x; this.y = y; this.vx = vx; this.vy = vy;
            this.life = life; this.baseLife = this.life > 0 ? this.life : PARTICLE_LIFESPAN;
            this.color = color;
            this.history = [];
        }
        update(attractorX, attractorY, attractionForce) {
            this.history.push({x: this.x, y: this.y});
            if (this.history.length > 5) this.history.shift();

            const dx = attractorX - this.x; const dy = attractorY - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 1) { this.vx += (dx / dist) * attractionForce; this.vy += (dy / dist) * attractionForce; }
            this.x += this.vx; this.y += this.vy;
            this.vx *= 0.97; this.vy *= 0.97; this.life--;
        }
        draw(blendColor = null, blendAmount = 0) {
            let finalColor = this.color;
            if (blendColor && blendAmount > 0) {
                finalColor = lerpColor(this.color, blendColor, blendAmount);
            }

            ctx.beginPath();
            ctx.moveTo(this.history[0]?.x || this.x, this.history[0]?.y || this.y);
            for (let i = 1; i < this.history.length; i++) ctx.lineTo(this.history[i].x, this.history[i].y);
            const trailAlpha = (this.life / this.baseLife) * 0.2;
            ctx.strokeStyle = finalColor.replace(/[\d\.]+\)$/g, `${trailAlpha})`);
            ctx.lineWidth = 1.5;
            ctx.stroke();

            const alpha = (this.life / this.baseLife) * 0.9;
            ctx.fillStyle = finalColor.replace(/[\d\.]+\)$/g, `${alpha})`);
            ctx.beginPath(); ctx.arc(this.x, this.y, 1.5, 0, Math.PI * 2); ctx.fill();
        }
    }

    // --- INITIALIZATION ---
    function init() {
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('focus', () => channel.postMessage({ type: 'focus', id: WINDOW_ID }));
        resizeCanvas();
        animate();
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        stars = [];
        nebulaColors = [
            { x: Math.random() * canvas.width, y: Math.random() * canvas.height, r: Math.random() * 400 + 200, color: 'rgba(34, 197, 94, 0.1)' },
            { x: Math.random() * canvas.width, y: Math.random() * canvas.height, r: Math.random() * 300 + 150, color: 'rgba(168, 85, 247, 0.05)' }
        ];
        if (canvas.width > 0 && canvas.height > 0) {
            for (let i = 0; i < 200; i++) stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, z: Math.random() * 2.5 + 0.5 });
        }
    }

    // --- COMMUNICATION ---
    const channel = new BroadcastChannel('portal_nexus_channel');
    channel.onmessage = (event) => {
        if (!event.data) return;
        switch(event.data.type) {
            case 'pos1':
                openerWindowPos = event.data.data; lastSeenTimestamp = Date.now(); break;
            case 'particle_transfer':
                if (event.data.target === WINDOW_ID) transferredParticles.push(new Particle(event.data.particle)); break;
            case 'focus':
                activeWindowId = event.data.id; break;
        }
    };

    // --- MAIN ANIMATION LOOP ---
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();

        const myPos = getMyPosition();
        channel.postMessage({ type: 'pos2', data: myPos });

        ringAngle1 += 0.01;
        ringAngle2 -= 0.005;

        const openerWindowPresent = Date.now() - lastSeenTimestamp < 1500;

        if (!openerWindowPresent) {
            infoStatus.innerHTML = `<strong>Core Nexus 2</strong><br>Status: Link Lost`;
            drawCore(myPos.cx, myPos.cy, CORE_COLOR, 40);
            requestAnimationFrame(animate);
            return;
        }

        const { dist } = calculateDistance(myPos, openerWindowPos);

        if (dist < MERGE_DISTANCE) {
            const isTopWindow = activeWindowId === WINDOW_ID;
            infoStatus.innerHTML = `<strong>Core Nexus 2</strong><br>Status: MERGED (${isTopWindow ? 'Top' : 'Bottom'})`;
            drawMergedState(myPos, isTopWindow);
        } else if (dist < ATTRACTION_RADIUS) {
            infoStatus.innerHTML = `<strong>Core Nexus 2</strong><br>Status: Filaments Active`;
            updateAndDrawFilaments(myPos, openerWindowPos, dist);
            drawCore(myPos.cx, myPos.cy, CORE_COLOR, 40);
        } else {
            infoStatus.innerHTML = `<strong>Core Nexus 2</strong><br>Status: Stable`;
            drawCore(myPos.cx, myPos.cy, CORE_COLOR, 40);
        }

        requestAnimationFrame(animate);
    }

    // --- DRAWING & LOGIC FUNCTIONS ---
    function drawMergedState(myPos, isTop) {
        const coreRadius = isTop ? 60 : 55;
        drawCore(myPos.cx, myPos.cy, MERGED_COLOR, coreRadius, isTop ? 1.0 : 0.7);
        if (particles.length < PARTICLE_COUNT) {
            particles.push(new Particle({x: myPos.cx, y: myPos.cy, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, color: MERGED_PARTICLE_COLOR}));
        }
        updateParticleList(particles, myPos, openerWindowPos, myPos.cx, myPos.cy, -0.02, 1);
    }

    function updateAndDrawFilaments(myPos, otherPos, dist) {
        const baseRadius = 40;
        const pulse = Math.sin(Date.now() * 0.002) * 5;
        const currentCoreRadius = baseRadius + pulse;

        const dx = (otherPos.x + otherPos.cx) - (myPos.x + myPos.cx);
        const dy = (otherPos.y + otherPos.cy) - (myPos.y + myPos.cy);
        const angle = Math.atan2(dy, dx);
        const spawnX = myPos.cx + Math.cos(angle) * currentCoreRadius;
        const spawnY = myPos.cy + Math.sin(angle) * currentCoreRadius;

        if (particles.length < PARTICLE_COUNT) {
            const initialSpeed = 2;
            const initialVx = Math.cos(angle) * initialSpeed;
            const initialVy = Math.sin(angle) * initialSpeed;
            particles.push(new Particle({x: spawnX, y: spawnY, vx: initialVx, vy: initialVy, color: PARTICLE_COLOR}));
        }
        const attractorX = otherPos.x - myPos.x + otherPos.cx;
        const attractorY = otherPos.y - myPos.y + otherPos.cy;
        const attractionForce = 1 - (dist / ATTRACTION_RADIUS);
        const blendAmount = Math.max(0, 1 - (dist - MERGE_DISTANCE) / (ATTRACTION_RADIUS / 2 - MERGE_DISTANCE));

        updateParticleList(particles, myPos, otherPos, attractorX, attractorY, attractionForce, 1, HOT_PARTICLE_COLOR, blendAmount);
        updateParticleList(transferredParticles, myPos, otherPos, attractorX, attractorY, attractionForce, 1, HOT_PARTICLE_COLOR, blendAmount);
    }

    function updateParticleList(list, myPos, otherPos, attractorX, attractorY, attractionForce, targetId, blendColor, blendAmount) {
        for (let i = list.length - 1; i >= 0; i--) {
            const p = list[i];
            p.update(attractorX, attractorY, attractionForce * 0.5);
            const screenX = myPos.x + p.x; const screenY = myPos.y + p.y;

            if (otherPos && screenX >= otherPos.x && screenX <= otherPos.x + otherPos.width && screenY >= otherPos.y && screenY <= otherPos.y + otherPos.height) {
                channel.postMessage({ type: 'particle_transfer', target: targetId, particle: { x: screenX - otherPos.x, y: screenY - otherPos.y, vx: p.vx, vy: p.vy, life: p.life, color: p.color } });
                list.splice(i, 1);
                continue;
            }

            p.draw(blendColor, blendAmount);
            if (p.life <= 0) list.splice(i, 1);
        }
    }

    function drawBackground() {
        if (canvas.width === 0 || canvas.height === 0) return;
        nebulaColors.forEach(neb => {
            const grad = ctx.createRadialGradient(neb.x, neb.y, 0, neb.x, neb.y, neb.r);
            grad.addColorStop(0, neb.color); grad.addColorStop(1, 'rgba(0,0,5,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0, canvas.width, canvas.height);
        });
        ctx.fillStyle = '#FFF';
        stars.forEach(star => {
            const x = (star.x - window.screenX / (star.z * 5)) % canvas.width;
            const y = (star.y - window.screenY / (star.z * 5)) % canvas.height;
            const size = (3 - star.z) * 0.5;
            ctx.globalAlpha = 1 / star.z * 0.5;
            ctx.beginPath(); ctx.arc(x < 0 ? x + canvas.width : x, y < 0 ? y + canvas.height : y, size, 0, Math.PI * 2); ctx.fill();
        });
        ctx.globalAlpha = 1;
    }

    function drawCore(x, y, color, baseRadius, opacity = 1.0) {
        ctx.globalAlpha = opacity;
        const pulse = Math.sin(Date.now() * 0.002) * 5;
        const radius = baseRadius + pulse;

        ctx.strokeStyle = color + '80'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.ellipse(x, y, radius * 1.5, radius * 0.5, ringAngle1, 0, Math.PI * 2); ctx.stroke();
        ctx.strokeStyle = color + '40'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.ellipse(x, y, radius * 0.8, radius * 1.8, ringAngle2, 0, Math.PI * 2); ctx.stroke();

        for (let i = 4; i > 0; i--) {
            const bloomRadius = radius + i * 10;
            const grad = ctx.createRadialGradient(x, y, radius, x, y, bloomRadius);
            grad.addColorStop(0, color + '20'); grad.addColorStop(1, color + '00');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x, y, bloomRadius, 0, Math.PI * 2); ctx.fill();
        }
        ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    // --- HELPERS ---
    function getMyPosition() { return { x: window.screenX, y: window.screenY, width: window.outerWidth, height: window.outerHeight, cx: window.innerWidth / 2, cy: window.innerHeight / 2 }; }
    function calculateDistance(pos1, pos2) { const dx = (pos1.x + pos1.width / 2) - (pos2.x + pos2.width / 2); const dy = (pos1.y + pos1.height / 2) - (pos2.y + pos2.height / 2); return { dist: Math.sqrt(dx * dx + dy * dy) }; }
    function lerpColor(color1, color2, amount) {
        const c1 = color1.match(/\d+/g).map(Number);
        const c2 = color2.match(/\d+/g).map(Number);
        const r = Math.round(c1[0] + (c2[0] - c1[0]) * amount);
        const g = Math.round(c1[1] + (c2[1] - c1[1]) * amount);
        const b = Math.round(c1[2] + (c2[2] - c1[2]) * amount);
        return `rgba(${r}, ${g}, ${b}, 0.9)`;
    }

    init();
</script>
</body>
</html>
