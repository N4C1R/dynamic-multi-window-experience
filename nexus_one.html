<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Nexus 1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #000005;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .info {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 0.75rem;
            border-radius: 0.5rem;
            color: #9ca3af;
            font-size: 0.875rem;
            border: 1px solid #374151;
        }
        .info strong { color: #e5e7eb; }
        #openWindowBtn {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: rgba(59, 130, 246, 0.4);
            border: 1px solid #3b82f6;
            color: #e5e7eb;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.3);
        }
        #openWindowBtn:hover {
            background: rgba(59, 130, 246, 0.7);
            box-shadow: 0 0 25px rgba(59, 130, 246, 0.5);
        }
    </style>
</head>
<body>
<div class="info">
    <strong>Core Nexus 1</strong><br>
    Status: Awaiting Link
</div>
<canvas id="canvas"></canvas>
<button id="openWindowBtn" style="display: none;">Launch Nexus 2</button>
<div id="webrtcPanel" style="display:none; position:absolute; right:1rem; top:1rem; z-index:20; background:rgba(0,0,0,0.5); border:1px solid #374151; border-radius:8px; padding:10px; width:290px; color:#9ca3af; font-size:12px;">
  <div style="color:#e5e7eb; font-weight:600; margin-bottom:6px;">Mobile P2P (WebRTC)</div>
  <div id="rtcStatus" style="margin-bottom:6px;">Status: Idle</div>
  <div style="display:flex; gap:6px; margin-bottom:6px;">
    <button id="btnCreateRoom" style="flex:1;">Create Room</button>
    <input id="joinCode" placeholder="Enter code" style="flex:1; padding:4px;"/>
    <button id="btnJoinRoom">Join</button>
  </div>
  <div id="roomCodeRow" style="display:none; margin-bottom:6px;">
    Room Code: <span id="roomCode" style="color:#e5e7eb; font-weight:600;"></span>
  </div>
  <div id="manualFallback" style="margin-top:8px; border-top:1px solid #374151; padding-top:6px;">
    <div style="margin-bottom:4px; color:#e5e7eb;">Manual Fallback</div>
<script>
  // Quick-start: paste your Ably API key here for testing only.
  // Example format: "APP_KEY:APP_SECRET". For production, use Token Auth via a small server.
  window.ABLY_API_KEY = 'r7PWXg.pBb0YA:JIMHvZmWQl4uxQtOcjkHQhrjBUhg25naeCY8TxanXoA';
</script>
<script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
    <button id="btnCreateOffer" style="margin:4px 0; width:100%;">Create Offer</button>
    <textarea id="offerOut" placeholder="Copy this offer" style="width:100%; height:70px; margin-bottom:6px;"></textarea>
    <textarea id="offerIn" placeholder="Paste remote offer (callee)" style="width:100%; height:70px; margin-bottom:6px;"></textarea>
    <button id="btnAcceptOffer" style="margin:4px 0; width:100%;">Accept Offer (Create Answer)</button>
    <textarea id="answerOut" placeholder="Copy this answer" style="width:100%; height:70px; margin-bottom:6px;"></textarea>
    <textarea id="answerIn" placeholder="Paste remote answer (caller)" style="width:100%; height:70px; margin-bottom:6px;"></textarea>
    <button id="btnAcceptAnswer" style="margin:4px 0; width:100%;">Accept Answer</button>
  </div>
</div>

<script type="module">
        import { getClientAreaPosition, resizeCanvasHiDPI, drawBackgroundShared, lerpColor, calculateDistance, Particle, updateParticleListShared, drawCore, drawPartnerCoreOverlay, drawMergeArcs } from './nexus_shared.js';
    // --- ENHANCED CONFIGURATION ---
    const WINDOW_ID = 1;
    const ATTRACTION_RADIUS = 900;
    const MERGE_DISTANCE = 100;
    const PARTICLE_COUNT = 120;
    const PARTICLE_LIFESPAN = 180;
    const CORE_COLOR = '#3b82f6'; // Blue
    const PARTICLE_COLOR = 'rgba(96, 165, 250, 0.9)';
    const HOT_PARTICLE_COLOR = 'rgba(236, 72, 153, 0.9)'; // Magenta
    const MERGED_COLOR = '#a855f7'; // Purple
    const MERGED_PARTICLE_COLOR = 'rgba(192, 132, 252, 0.9)';

    // --- SETUP ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const infoStatus = document.querySelector('.info');
    const openBtn = document.getElementById('openWindowBtn');

    // --- MOBILE MODE (P2P) SWITCH ---
    const isMobile = matchMedia('(pointer: coarse)').matches || innerWidth < 850;
    const webrtcPanel = document.getElementById('webrtcPanel');
    const rtcStatusEl = document.getElementById('rtcStatus');
    const btnCreateOffer = document.getElementById('btnCreateOffer');
    const btnAcceptOffer = document.getElementById('btnAcceptOffer');
    const btnAcceptAnswer = document.getElementById('btnAcceptAnswer');
    const offerOut = document.getElementById('offerOut');
    const offerIn = document.getElementById('offerIn');
    const answerOut = document.getElementById('answerOut');
    const answerIn = document.getElementById('answerIn');

    // Local/remote cores for mobile P2P mode (single canvas)
    const coreA = { x: innerWidth*0.33, y: innerHeight*0.5 };
    // Signaling via WebSocket (configurable URL), fallback to manual
    const SIGNALING_URL = (window.NEXUS_SIGNALING_URL || ''); // e.g., wss://example.com/signaling
    let ws = null; let room = null; let isLeader = false; let wsConnected = false;

    function randCode(n=6){
        const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
        let s=''; for(let i=0;i<n;i++) s+=chars[(Math.random()*chars.length)|0];
        return s;
    }

    const btnCreateRoom = document.getElementById('btnCreateRoom');
    // --- Ably signaling ---
    let ably = null; let ablyChannel = null; let ablyReady = false;

    async function ensureAbly(){
        if (ably || !window.Ably) return;
        // For free plan testing: API key in client. For production, use TokenAuth.
        try {
            const key = window.ABLY_API_KEY || '';
            if (!key) { setStatus('Ably key not set (using manual fallback)'); return; }
            ably = new Ably.Realtime.Promise({ key, clientId: 'm' + Math.random().toString(36).slice(2,8), echoMessages: false });
            ably.connection.on('connected', ()=>{ ablyReady = true; setStatus('Ably connected'); });
            ably.connection.on('failed', ()=>{ ablyReady = false; setStatus('Ably failed (manual fallback)'); });
        } catch(e) { setStatus('Ably init error (manual fallback)'); }
    }

    async function ablyJoinRoom(code){
        await ensureAbly(); if (!ablyReady) return false;
        room = code.trim().toUpperCase(); isLeader = false; roomCodeRow.style.display='none';
        ablyChannel = ably.channels.get('nexus-' + room);
        await ablyChannel.attach();
        ablyChannel.subscribe('offer', (msg)=> acceptRemoteOffer(msg.data));
        ablyChannel.subscribe('answer', (msg)=> acceptRemoteAnswer(msg.data));
        ablyChannel.subscribe('ice', (msg)=> { if (pc) pc.addIceCandidate(msg.data).catch(()=>{}); });
        setStatus('Waiting for offer on ' + room);
        return true;
    }

    async function ablyCreateRoom(){
        await ensureAbly(); if (!ablyReady) return false;
        room = randCode(); isLeader = true; roomCodeEl.textContent = room; roomCodeRow.style.display='block';
        ablyChannel = ably.channels.get('nexus-' + room);
        await ablyChannel.attach();
        ablyChannel.subscribe('answer', (msg)=> acceptRemoteAnswer(msg.data));
        ablyChannel.subscribe('ice', (msg)=> { if (pc) pc.addIceCandidate(msg.data).catch(()=>{}); });
        setStatus('Room created. Waiting for peer...');
        return true;
    }

    function ablySend(type, data){
        if (ablyChannel) ablyChannel.publish(type, data).catch(()=>{});
    }
    const btnJoinRoom = document.getElementById('btnJoinRoom');
    const joinCode = document.getElementById('joinCode');
    const roomCodeEl = document.getElementById('roomCode');
    const roomCodeRow = document.getElementById('roomCodeRow');
    const manualFallback = document.getElementById('manualFallback');

    function setStatus(s){ rtcStatusEl.textContent = 'Status: ' + s; }

    function ensureWS(){
        if (ws || !SIGNALING_URL) return;
        try {
            ws = new WebSocket(SIGNALING_URL);
            ws.onopen = ()=>{ wsConnected = true; setStatus('Signaling connected'); };
            ws.onclose = ()=>{ wsConnected = false; setStatus('Signaling unavailable (using manual)'); };
            ws.onmessage = (ev)=>{ try{ const m = JSON.parse(ev.data); onSignal(m); }catch(e){} };
        } catch(e) { setStatus('Signaling error (manual only)'); }
    }

    function wsSend(obj){ if (ws && ws.readyState===1) ws.send(JSON.stringify(obj)); }

    function onSignal(m){
        if (!m || m.room !== room) return;
        if (m.type === 'roomStatus') {
            if (m.ok === false) setStatus(m.reason || 'Room error');
        } else if (m.type === 'offer' && !isLeader) {
            acceptRemoteOffer(m.sdp);
        } else if (m.type === 'answer' && isLeader) {
            acceptRemoteAnswer(m.sdp);
        } else if (m.type === 'ice') {
            if (pc) pc.addIceCandidate(m.candidate).catch(()=>{});
        }
    }

    async function createRoom(){
        // Prefer Ably. If unavailable, fallback to WebSocket URL; otherwise manual
        if (await ablyCreateRoom()) {
            await createPC();
            dc = pc.createDataChannel('nexus'); bindDC();
            pc.onicecandidate = (e) => { if (e.candidate) ablySend('ice', e.candidate); };
            const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
            ablySend('offer', offer);
            return;
        }
        ensureWS(); if (wsConnected) {
            room = randCode(); isLeader = true; roomCodeEl.textContent = room; roomCodeRow.style.display='block';
            setStatus('Room created. Waiting for peer...');
            await createPC();
            dc = pc.createDataChannel('nexus'); bindDC();
            pc.onicecandidate = (e) => { if (e.candidate) wsSend({ type:'ice', room, candidate:e.candidate }); };
            const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
            wsSend({ type:'offer', room, sdp:offer });
            return;
        }
        setStatus('No signaling available. Use manual fallback below.');
    }

    async function joinRoom(code){
        if (await ablyJoinRoom(code)) {
            await createPC();
            pc.onicecandidate = (e) => { if (e.candidate) ablySend('ice', e.candidate); };
            setStatus('Waiting for offer...');
            return;
        }
        ensureWS(); if (wsConnected) {
            room = code.trim().toUpperCase(); isLeader=false; roomCodeRow.style.display='none';
            setStatus('Joining room ' + room + ' ...');
            await createPC();
            pc.onicecandidate = (e) => { if (e.candidate) wsSend({ type:'ice', room, candidate:e.candidate }); };
            wsSend({ type:'join', room });
            setStatus('Waiting for offer...');
            return;
        }
        setStatus('No signaling available. Use manual fallback below.');
    }

    async function acceptRemoteOffer(offer){
        try {
            await pc.setRemoteDescription(offer);
            const ans = await pc.createAnswer(); await pc.setLocalDescription(ans);
            if (ablyChannel) ablySend('answer', ans); else wsSend({ type:'answer', room, sdp: ans });
            setStatus('Answer sent. Connecting...');
        } catch(e){ setStatus('Error accepting offer'); }
    }

    async function acceptRemoteAnswer(answer){
        try { await pc.setRemoteDescription(answer); setStatus('Connecting...'); }
        catch(e){ setStatus('Error accepting answer'); }
    }

    if (isMobile) {
        btnCreateRoom.onclick = () => createRoom();
        btnJoinRoom.onclick = () => joinRoom(joinCode.value);
        // Hide manual by default if Ably SDK is present and a key is set
        if (window.Ably && window.ABLY_API_KEY) manualFallback.style.display = 'none';
    }
    const remote = { cur: { x: innerWidth*0.66, y: innerHeight*0.5 }, tgt: { x: innerWidth*0.66, y: innerHeight*0.5 }, lastT: 0 };
    let dragging = false;

    // WebRTC objects
    let pc = null; let dc = null; let isCaller = false;
    let transport = { send: (m)=>{ if (dc && dc.readyState==='open') dc.send(JSON.stringify(m)); } };

    if (isMobile) {
        webrtcPanel.style.display = 'block';
    }
    let otherWindowPos = null;
    let lastSeenTimestamp = 0;
    let particles = [];
    let transferredParticles = [];
    let ghostParticles = [];
    let stars = [];
    let nebulaColors = [];
    let popupBlocked = false;
    let activeWindowId = 1;
    let ringAngle1 = 0;
    let ringAngle2 = 0;
    let partnerFound = false;

    // Particle class moved to shared module

    // --- INITIALIZATION ---
    function init() {
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('focus', () => channel.postMessage({ type: 'focus', id: WINDOW_ID }));
        window.addEventListener('blur', () => channel.postMessage({ type: 'blur', id: WINDOW_ID }));
        window.addEventListener('beforeunload', () => channel.postMessage({ type: 'closed', id: WINDOW_ID }));
        openBtn.addEventListener('click', () => {
            const newWindow = window.open('nexus_two.html', 'PortalWindow2', 'width=480,height=420,left=600,top=200');
            if (!newWindow) {
                popupBlocked = true;
                infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: Pop-up Blocked`;
            } else {
                popupBlocked = false;
                openBtn.style.display = 'none';
            }
        });
        resizeCanvas();

    // --- Touch controls (mobile) ---
    if (isMobile) {
        canvas.addEventListener('pointerdown', (e)=>{
            const p = { x: e.offsetX, y: e.offsetY };
            dragging = Math.hypot(p.x-coreA.x, p.y-coreA.y) < 56;
        }, {passive:true});
        canvas.addEventListener('pointermove', (e)=>{
            if (!dragging) return;
            coreA.x = e.offsetX; coreA.y = e.offsetY;
            maybeSendPos();
        }, {passive:true});
        canvas.addEventListener('pointerup', ()=>{ dragging=false; }, {passive:true});
        canvas.addEventListener('pointercancel', ()=>{ dragging=false; }, {passive:true});
    }

    function maybeSendPos(){
        const now = performance.now();
        if (!maybeSendPos._t) maybeSendPos._t = 0;
        if (now - maybeSendPos._t > 50) {
            transport.send({ type:'pos', t: Date.now(), x: coreA.x, y: coreA.y });
            maybeSendPos._t = now;
        }
    }

    function smoothRemote(dt = 0.12){
        remote.cur.x += (remote.tgt.x - remote.cur.x) * dt;
        remote.cur.y += (remote.tgt.y - remote.cur.y) * dt;
    }
        if (!isMobile) {
            channel.postMessage({ type: 'ping', id: WINDOW_ID });
            const attemptOpen = () => {
                if (!partnerFound && !popupBlocked) {
                    const w = window.open('nexus_two.html', 'PortalWindow2', 'width=480,height=420,left=600,top=200');
                    if (!w) {
                        popupBlocked = true;
                        openBtn.style.display = 'block';
                    }
                }
            };
            setTimeout(attemptOpen, 250);
            setTimeout(attemptOpen, 2000);
        } else {
            // Hide desktop launch button in mobile mode
            openBtn.style.display = 'none';
        }

        // Initialize animation
        animate();
    }

    // --- WebRTC manual signaling helpers (bundle-only SDP to reduce steps) ---
    async function createPC() {
        pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        pc.onicegatheringstatechange = () => {
            if (pc.iceGatheringState === 'complete') {
                const sdp = pc.localDescription;
                const text = btoa(JSON.stringify(sdp));
                if (isCaller) offerOut.value = text; else answerOut.value = text;
            }
        };
        pc.onconnectionstatechange = () => { rtcStatusEl.textContent = 'Status: ' + pc.connectionState; };
        if (!isCaller) {
            pc.ondatachannel = (e) => { dc = e.channel; bindDC(); };
        }
        return pc;
    }

    function bindDC(){
        dc.onopen = ()=>{ rtcStatusEl.textContent = 'Status: Connected'; };
        dc.onclose = ()=>{ rtcStatusEl.textContent = 'Status: Closed'; };
        dc.onmessage = (ev)=>{
            try { const m = JSON.parse(ev.data); onMessage(m); } catch(e) {}
        };
    }

    function onMessage(m){
        if (m.type === 'pos') {
            remote.tgt.x = m.x; remote.tgt.y = m.y; remote.lastT = m.t || Date.now();
        }
    }

    if (isMobile) {
        btnCreateOffer.onclick = async () => {
            isCaller = true; await createPC();
            dc = pc.createDataChannel('nexus'); bindDC();
            const offer = await pc.createOffer({ iceRestart: false });
            await pc.setLocalDescription(offer);
            rtcStatusEl.textContent = 'Status: Offer ready (copy)';
        };
        btnAcceptOffer.onclick = async () => {
            isCaller = false; await createPC();
            const remoteOffer = JSON.parse(atob(offerIn.value.trim()));
            await pc.setRemoteDescription(remoteOffer);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            rtcStatusEl.textContent = 'Status: Answer ready (copy)';
        };
        btnAcceptAnswer.onclick = async () => {
            const remoteAnswer = JSON.parse(atob(answerIn.value.trim()));
            await pc.setRemoteDescription(remoteAnswer);
            rtcStatusEl.textContent = 'Status: Connecting...';
        };
    }

    function resizeCanvas() {
        resizeCanvasHiDPI(canvas, ctx, window.innerWidth, window.innerHeight);

        stars = [];
        const w = window.innerWidth;
        const h = window.innerHeight;
        nebulaColors = [
            { x: Math.random() * w, y: Math.random() * h, r: Math.random() * 400 + 200, color: 'rgba(59, 130, 246, 0.1)' },
            { x: Math.random() * w, y: Math.random() * h, r: Math.random() * 300 + 150, color: 'rgba(168, 85, 247, 0.05)' }
        ];
        if (w > 0 && h > 0) {
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    z: Math.random() * 2.5 + 0.5
                });
            }
        }
    }

    // --- COMMUNICATION ---
    const channel = new BroadcastChannel('portal_nexus_channel');
    channel.onmessage = (event) => {
        if (!event.data) return;
        switch(event.data.type) {
            case 'pos2':
                otherWindowPos = event.data.data;
                lastSeenTimestamp = Date.now();
                break;
            case 'closed':
                partnerFound = false;
                lastSeenTimestamp = 0;
                openBtn.style.display = 'block';
                break;
            case 'particle_transfer':
                if (event.data.target === WINDOW_ID) {
                    transferredParticles.push(
                        new Particle({
                            ...event.data.particle,
                            targetX: window.innerWidth / 2,
                            targetY: window.innerHeight / 2
                        })
                    );
                }
                break;
            case 'ghost_particle':
                if (event.data.target === WINDOW_ID) {
                    ghostParticles.push(event.data.particle);
                }
                break;
            case 'focus':
                activeWindowId = event.data.id;
                break;
            case 'ping':
            case 'pong':
                if (event.data.id !== WINDOW_ID) {
                    partnerFound = true;
                    channel.postMessage({ type: 'pong', id: WINDOW_ID });
                }
                break;
        }
    };

    // --- MAIN ANIMATION LOOP ---
    function animate() {
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        drawBackgroundShared(ctx, stars, nebulaColors, window.screenX, window.screenY, window.innerWidth, window.innerHeight);

        ringAngle1 += 0.01; ringAngle2 -= 0.005;

        if (isMobile) {
            // Single-canvas dual-core rendering
            smoothRemote();
            // Update particles for both directions (reuse existing list, fewer spawns)
            const dx = remote.cur.x - coreA.x, dy = remote.cur.y - coreA.y;
            const dist = Math.hypot(dx, dy);
            if (particles.length < PARTICLE_COUNT && Math.random() > 0.3) {
                const ang = Math.atan2(dy, dx), sp=2.2, spawnR=40;
                particles.push(new Particle({ x: coreA.x+Math.cos(ang)*spawnR, y: coreA.y+Math.sin(ang)*spawnR, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, color: PARTICLE_COLOR, targetX: remote.cur.x, targetY: remote.cur.y }));
                particles.push(new Particle({ x: remote.cur.x-Math.cos(ang)*spawnR, y: remote.cur.y-Math.sin(ang)*spawnR, vx: -Math.cos(ang)*sp, vy: -Math.sin(ang)*sp, color: 'rgba(74, 222, 128, 0.9)', targetX: coreA.x, targetY: coreA.y }));
            }
            // Update/draw particles
            for (let i=particles.length-1;i>=0;i--) {
                const p=particles[i];
                const ax = (p.targetX===remote.cur.x && p.targetY===remote.cur.y) ? remote.cur.x : coreA.x;
                const ay = (p.targetX===remote.cur.x && p.targetY===remote.cur.y) ? remote.cur.y : coreA.y;
                p.update(ax, ay, Math.max(0, 1 - dist/ATTRACTION_RADIUS));
                p.draw(ctx);
                if (p.life<=0) particles.splice(i,1);
            }
            // Draw cores and arcs
            drawCore(ctx, coreA.x, coreA.y, CORE_COLOR, 40, ringAngle1, ringAngle2);
            drawCore(ctx, remote.cur.x, remote.cur.y, '#16a34a', 40, ringAngle1, ringAngle2);
            drawMergeArcs(ctx, coreA.x, coreA.y, remote.cur.x, remote.cur.y);

            requestAnimationFrame(animate);
            return;
        }

        // Desktop multi-window logic (unchanged)
        const myPos = getClientAreaPosition();
        channel.postMessage({ type: 'pos1', data: myPos });

        const otherWindowPresent = Date.now() - lastSeenTimestamp < 1500;
        if (!otherWindowPresent) {
            handleNoLink(myPos);
            requestAnimationFrame(animate);
            return;
        }

        openBtn.style.display = 'none';
        const { dist } = calculateDistance(myPos, otherWindowPos);

        if (dist < MERGE_DISTANCE) {
            const isTopWindow = activeWindowId === WINDOW_ID;
            infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: MERGED (${isTopWindow ? 'Top' : 'Bottom'})`;
            drawMergedState(myPos, isTopWindow);
        } else if (dist < ATTRACTION_RADIUS) {
            infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: Filaments Active`;
            updateAndDrawFilaments(myPos, otherWindowPos, dist);
            drawCore(ctx, myPos.cx, myPos.cy, CORE_COLOR, 40, ringAngle1, ringAngle2);
            drawMergeArcs(ctx, myPos.cx, myPos.cy, otherWindowPos.x - myPos.x + otherWindowPos.cx, otherWindowPos.y - myPos.y + otherWindowPos.cy);
        } else {
            infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: Stable`;
            drawCore(ctx, myPos.cx, myPos.cy, CORE_COLOR, 40, ringAngle1, ringAngle2);
        }
        drawPartnerCoreOverlay(ctx, myPos, otherWindowPos, '#16a34a', ringAngle1, ringAngle2);

        ghostParticles.forEach(p => new Particle(p).draw(ctx));
        ghostParticles = [];

        requestAnimationFrame(animate);
    }



    // --- DRAWING & LOGIC FUNCTIONS ---
    function drawMergedState(myPos, isTop) {
        const coreRadius = isTop ? 60 : 55;
        drawCore(ctx, myPos.cx, myPos.cy, MERGED_COLOR, coreRadius, ringAngle1, ringAngle2, isTop ? 1.0 : 0.7);
        if (particles.length < PARTICLE_COUNT) {
            particles.push(new Particle({
                x: myPos.cx,
                y: myPos.cy,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                color: MERGED_PARTICLE_COLOR
            }));
        }
        updateParticleListShared(ctx, channel, particles, myPos, otherWindowPos, myPos.cx, myPos.cy, -0.02, 2);
    }

    function updateAndDrawFilaments(myPos, otherPos, dist) {
        const baseRadius = 40;
        const pulse = Math.sin(Date.now() * 0.002) * 5;
        const currentCoreRadius = baseRadius + pulse;

        const dx = (otherPos.x + otherPos.cx) - (myPos.x + myPos.cx);
        const dy = (otherPos.y + otherPos.cy) - (myPos.y + myPos.cy);
        const angle = Math.atan2(dy, dx);

        if (particles.length < PARTICLE_COUNT && Math.random() > 0.3) {
            const spawnX = myPos.cx + Math.cos(angle) * currentCoreRadius;
            const spawnY = myPos.cy + Math.sin(angle) * currentCoreRadius;
            const initialSpeed = 2.5;
            const initialVx = Math.cos(angle) * initialSpeed;
            const initialVy = Math.sin(angle) * initialSpeed;

            particles.push(new Particle({
                x: spawnX,
                y: spawnY,
                vx: initialVx,
                vy: initialVy,
                color: PARTICLE_COLOR,
                targetX: otherPos.cx + (otherPos.x - myPos.x),
                targetY: otherPos.cy + (otherPos.y - myPos.y)
            }));
        }

        const attractorX = otherPos.x - myPos.x + otherPos.cx;
        const attractorY = otherPos.y - myPos.y + otherPos.cy;
        const attractionForce = 1 - (dist / ATTRACTION_RADIUS);
        const blendAmount = Math.max(0, 1 - (dist - MERGE_DISTANCE) / (ATTRACTION_RADIUS / 2 - MERGE_DISTANCE));

        updateParticleListShared(ctx, channel, particles, myPos, otherPos, attractorX, attractorY, attractionForce, 2, HOT_PARTICLE_COLOR, blendAmount);
        updateParticleListShared(ctx, channel, transferredParticles, myPos, otherPos, attractorX, attractorY, attractionForce, 2, HOT_PARTICLE_COLOR, blendAmount);
    }

    // updateParticleList moved to shared module

    // drawBackground and drawCore moved to shared module

    function handleNoLink(myPos) {
        if (popupBlocked) {
            infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: Pop-up Blocked`;
            openBtn.style.display = 'block';
        } else {
            infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: Awaiting Link`;
        }
        // Draw core while waiting (use shared drawCore with context and ring angles)
        drawCore(ctx, myPos.cx, myPos.cy, CORE_COLOR, 40, ringAngle1, ringAngle2);
    }

    // --- HELPERS ---
    // getMyPosition, calculateDistance, lerpColor moved to shared module

    init();
</script>
</body>
</html>