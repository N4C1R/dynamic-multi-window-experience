<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Nexus 1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #000005;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .info {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 0.75rem;
            border-radius: 0.5rem;
            color: #9ca3af;
            font-size: 0.875rem;
            border: 1px solid #374151;
        }
        .info strong { color: #e5e7eb; }
        #openWindowBtn {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: rgba(59, 130, 246, 0.4);
            border: 1px solid #3b82f6;
            color: #e5e7eb;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.3);
        }
        #openWindowBtn:hover {
            background: rgba(59, 130, 246, 0.7);
            box-shadow: 0 0 25px rgba(59, 130, 246, 0.5);
        }
    </style>
</head>
<body>
<div class="info">
    <strong>Core Nexus 1</strong><br>
    Status: Awaiting Link
</div>
<canvas id="canvas"></canvas>
<button id="openWindowBtn" style="display: none;">Launch Nexus 2</button>

<script type="module">
        import { getClientAreaPosition, resizeCanvasHiDPI, drawBackgroundShared, lerpColor, calculateDistance, Particle, updateParticleListShared, drawCore, drawPartnerCoreOverlay, drawMergeArcs } from './nexus_shared.js';
    // --- ENHANCED CONFIGURATION ---
    const WINDOW_ID = 1;
    const ATTRACTION_RADIUS = 900;
    const MERGE_DISTANCE = 100;
    const PARTICLE_COUNT = 120;
    const PARTICLE_LIFESPAN = 180;
    const CORE_COLOR = '#3b82f6'; // Blue
    const PARTICLE_COLOR = 'rgba(96, 165, 250, 0.9)';
    const HOT_PARTICLE_COLOR = 'rgba(236, 72, 153, 0.9)'; // Magenta
    const MERGED_COLOR = '#a855f7'; // Purple
    const MERGED_PARTICLE_COLOR = 'rgba(192, 132, 252, 0.9)';

    // --- SETUP ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const infoStatus = document.querySelector('.info');
    const openBtn = document.getElementById('openWindowBtn');

    let otherWindowPos = null;
    let lastSeenTimestamp = 0;
    let particles = [];
    let transferredParticles = [];
    let ghostParticles = [];
    let stars = [];
    let nebulaColors = [];
    let popupBlocked = false;
    let activeWindowId = 1;
    let ringAngle1 = 0;
    let ringAngle2 = 0;
    let partnerFound = false;

    // Particle class moved to shared module

    // --- INITIALIZATION ---
    function init() {
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('focus', () => channel.postMessage({ type: 'focus', id: WINDOW_ID }));
        window.addEventListener('blur', () => channel.postMessage({ type: 'blur', id: WINDOW_ID }));
        window.addEventListener('beforeunload', () => channel.postMessage({ type: 'closed', id: WINDOW_ID }));
        openBtn.addEventListener('click', () => {
            const newWindow = window.open('nexus_two.html', 'PortalWindow2', 'width=480,height=420,left=600,top=200');
            if (!newWindow) {
                popupBlocked = true;
                infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: Pop-up Blocked`;
            } else {
                popupBlocked = false;
                openBtn.style.display = 'none';
            }
        });
        resizeCanvas();

        channel.postMessage({ type: 'ping', id: WINDOW_ID });
        const attemptOpen = () => {
            if (!partnerFound && !popupBlocked) {
                const w = window.open('nexus_two.html', 'PortalWindow2', 'width=480,height=420,left=600,top=200');
                if (!w) {
                    popupBlocked = true;
                    openBtn.style.display = 'block';
                }
            }
        };
        setTimeout(attemptOpen, 250);
        setTimeout(attemptOpen, 2000);

        animate();
    }

    function resizeCanvas() {
        resizeCanvasHiDPI(canvas, ctx, window.innerWidth, window.innerHeight);

        stars = [];
        const w = window.innerWidth;
        const h = window.innerHeight;
        nebulaColors = [
            { x: Math.random() * w, y: Math.random() * h, r: Math.random() * 400 + 200, color: 'rgba(59, 130, 246, 0.1)' },
            { x: Math.random() * w, y: Math.random() * h, r: Math.random() * 300 + 150, color: 'rgba(168, 85, 247, 0.05)' }
        ];
        if (w > 0 && h > 0) {
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    z: Math.random() * 2.5 + 0.5
                });
            }
        }
    }

    // --- COMMUNICATION ---
    const channel = new BroadcastChannel('portal_nexus_channel');
    channel.onmessage = (event) => {
        if (!event.data) return;
        switch(event.data.type) {
            case 'pos2':
                otherWindowPos = event.data.data;
                lastSeenTimestamp = Date.now();
                break;
            case 'closed':
                partnerFound = false;
                lastSeenTimestamp = 0;
                openBtn.style.display = 'block';
                break;
            case 'particle_transfer':
                if (event.data.target === WINDOW_ID) {
                    transferredParticles.push(
                        new Particle({
                            ...event.data.particle,
                            targetX: window.innerWidth / 2,
                            targetY: window.innerHeight / 2
                        })
                    );
                }
                break;
            case 'ghost_particle':
                if (event.data.target === WINDOW_ID) {
                    ghostParticles.push(event.data.particle);
                }
                break;
            case 'focus':
                activeWindowId = event.data.id;
                break;
            case 'ping':
            case 'pong':
                if (event.data.id !== WINDOW_ID) {
                    partnerFound = true;
                    channel.postMessage({ type: 'pong', id: WINDOW_ID });
                }
                break;
        }
    };

    // --- MAIN ANIMATION LOOP ---
    function animate() {
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        drawBackgroundShared(ctx, stars, nebulaColors, window.screenX, window.screenY, window.innerWidth, window.innerHeight);

        const myPos = getClientAreaPosition();
        channel.postMessage({ type: 'pos1', data: myPos });

        const otherWindowPresent = Date.now() - lastSeenTimestamp < 1500;

        ringAngle1 += 0.01;
        ringAngle2 -= 0.005;

        if (!otherWindowPresent) {
            handleNoLink(myPos);
            requestAnimationFrame(animate);
            return;
        }

        openBtn.style.display = 'none';
        const { dist } = calculateDistance(myPos, otherWindowPos);

        if (dist < MERGE_DISTANCE) {
            const isTopWindow = activeWindowId === WINDOW_ID;
            infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: MERGED (${isTopWindow ? 'Top' : 'Bottom'})`;
            drawMergedState(myPos, isTopWindow);
        } else if (dist < ATTRACTION_RADIUS) {
            infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: Filaments Active`;
            updateAndDrawFilaments(myPos, otherWindowPos, dist);
            drawCore(ctx, myPos.cx, myPos.cy, CORE_COLOR, 40, ringAngle1, ringAngle2);
            // Energy arcs between cores
            drawMergeArcs(ctx, myPos.cx, myPos.cy, otherWindowPos.x - myPos.x + otherWindowPos.cx, otherWindowPos.y - myPos.y + otherWindowPos.cy);
        } else {
            infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: Stable`;
            drawCore(ctx, myPos.cx, myPos.cy, CORE_COLOR, 40, ringAngle1, ringAngle2);
        }
        // Show partner core overlay for visibility when overlapping
        drawPartnerCoreOverlay(ctx, myPos, otherWindowPos, '#16a34a', ringAngle1, ringAngle2);

        ghostParticles.forEach(p => new Particle(p).draw(ctx));
        ghostParticles = [];

        requestAnimationFrame(animate);
    }



    // --- DRAWING & LOGIC FUNCTIONS ---
    function drawMergedState(myPos, isTop) {
        const coreRadius = isTop ? 60 : 55;
        drawCore(ctx, myPos.cx, myPos.cy, MERGED_COLOR, coreRadius, ringAngle1, ringAngle2, isTop ? 1.0 : 0.7);
        if (particles.length < PARTICLE_COUNT) {
            particles.push(new Particle({
                x: myPos.cx,
                y: myPos.cy,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                color: MERGED_PARTICLE_COLOR
            }));
        }
        updateParticleListShared(ctx, channel, particles, myPos, otherWindowPos, myPos.cx, myPos.cy, -0.02, 2);
    }

    function updateAndDrawFilaments(myPos, otherPos, dist) {
        const baseRadius = 40;
        const pulse = Math.sin(Date.now() * 0.002) * 5;
        const currentCoreRadius = baseRadius + pulse;

        const dx = (otherPos.x + otherPos.cx) - (myPos.x + myPos.cx);
        const dy = (otherPos.y + otherPos.cy) - (myPos.y + myPos.cy);
        const angle = Math.atan2(dy, dx);

        if (particles.length < PARTICLE_COUNT && Math.random() > 0.3) {
            const spawnX = myPos.cx + Math.cos(angle) * currentCoreRadius;
            const spawnY = myPos.cy + Math.sin(angle) * currentCoreRadius;
            const initialSpeed = 2.5;
            const initialVx = Math.cos(angle) * initialSpeed;
            const initialVy = Math.sin(angle) * initialSpeed;

            particles.push(new Particle({
                x: spawnX,
                y: spawnY,
                vx: initialVx,
                vy: initialVy,
                color: PARTICLE_COLOR,
                targetX: otherPos.cx + (otherPos.x - myPos.x),
                targetY: otherPos.cy + (otherPos.y - myPos.y)
            }));
        }

        const attractorX = otherPos.x - myPos.x + otherPos.cx;
        const attractorY = otherPos.y - myPos.y + otherPos.cy;
        const attractionForce = 1 - (dist / ATTRACTION_RADIUS);
        const blendAmount = Math.max(0, 1 - (dist - MERGE_DISTANCE) / (ATTRACTION_RADIUS / 2 - MERGE_DISTANCE));

        updateParticleListShared(ctx, channel, particles, myPos, otherPos, attractorX, attractorY, attractionForce, 2, HOT_PARTICLE_COLOR, blendAmount);
        updateParticleListShared(ctx, channel, transferredParticles, myPos, otherPos, attractorX, attractorY, attractionForce, 2, HOT_PARTICLE_COLOR, blendAmount);
    }

    // updateParticleList moved to shared module

    // drawBackground and drawCore moved to shared module

    function handleNoLink(myPos) {
        if (popupBlocked) {
            infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: Pop-up Blocked`;
            openBtn.style.display = 'block';
        } else {
            infoStatus.innerHTML = `<strong>Core Nexus 1</strong><br>Status: Awaiting Link`;
        }
        // Draw core while waiting (use shared drawCore with context and ring angles)
        drawCore(ctx, myPos.cx, myPos.cy, CORE_COLOR, 40, ringAngle1, ringAngle2);
    }

    // --- HELPERS ---
    // getMyPosition, calculateDistance, lerpColor moved to shared module

    init();
</script>
</body>
</html>